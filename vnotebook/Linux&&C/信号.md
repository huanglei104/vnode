信号的数目：
     通过 kill -l 查看 
     1-31 不可靠信号  产生了多次，进程可能只会注册一次
     34-64 可靠信号   产生多少次，进程就会注册多少次
     不存在编号为0的信号，向进程发送0信号常用来查检进程是否存在。
信号的注册：
     通过signal 或sigaction函数。前者是通过后者来实现的，所以推荐使用后者。
     信号的处理函数除了自定义的函数之外，也可以是SIG_IGN(忽略)；SIG_DFL(默认动作)。 
      SIGKILL(9)和SIGSTOP(19)不能捕捉或忽略
信号的阻塞： 
     使用sigprocmask函数。sigaction也能阻塞信号, 但只是在执行信号处理函数时阻塞。

void (*signal(int sig, void (*func)(int)))(int);
signal先与()结合，说明是一个函数，再与\*结合，说明函数的返回值是一个指针，再与(int)结合，说明指针指向一个形参为int的函数，最后与void结合，说明指向的函数的返回值是void

收到信号要执行的动作：SIG_IGN(忽略)；SIG_DFL(默认动作)；执行一个函数。 SIG_ERR 表示signal函数调用错误

signal的返回值类型为__sighandler_t， 是在此之前的信号处理函数的指针

linux的系统调用分为两种：低速系统调用和其他系统调用。低速系统调用是可能使系统永远阻塞的一类系统调用，低速的系统调用会被信号打断。

pause和wait会被信号打断。

signal函数中，正在处理信号a，如果又来了信号a，则第二个信号a并不能立即得到处理，如果来了信号b,则信号a的处理会被中断，先转去处理信号b

当使用signal函数时，被中断的系统系统会自动重启，当使用用户自己实现的signal函数(sigaction)时，不会自动重启。被信号中断会自动重启的系统调用包括：ioctl,read,readv,write,writev,wait,waitpid。前5个只在操作低速设备时才会被中断。只有信号的SA_RESTART标志被设置了才会自动重启。
     
fork不改变信号的处理方式，所以子进程与父进程的信号处理方式相同，exec将信号的处理方式都改为默认的。

信号的3种状态：
（1）信号递达（Delivery）：实际执行信号的处理动作称为信号递达；
（2）信号未决（Pending）：信号从产生到递达之间的状态；     
（3）信号阻塞（Block）：被阻塞的信号产生时将保持在未决状态，直到进程解除对此信号的阻塞，才执行递达的动作；
注意：阻塞与忽略是不同的，只要信号被阻塞就不会递达，而忽略是在递达之后可选的一种处理动作。

每个进程只能有一个闹钟

如果一个自己重启的系统调用被中断，则中断处理程序返回后，系统调用会被重启，而不会返回

sigprcomask： 屏蔽或解屏蔽信号，在调用该函数后，如果进程有未决的并不再阻塞的信号 ，则在该函数返回之前，至少将其中之一递送给该进程 。
          该函数只能在单进程中使用，在多进程中使用另外的函数
sigpending：获取在阻塞期间产生的信号，未决的信号。

sigaction 执行信号处理函数时，默认该信号本身也会被屏蔽。

在信号的处理函数中，应该使用sigsetjmp/siglongjmp来替代setjmp/longjmp

在sigprocmask(解除信号阻塞)和pause之间发生的信号会丢失，为了解决该问题，就有了
sigsuspend:   设置进程的信号屏蔽字并挂起，直到被唤醒，且返回为-1,errno为EINTR ,且恢复之前的信号屏蔽字

abrt()会向进程发送SIGABRT信号，即使信号被捕捉且信号处理函数返回了，abrt也不会返回到调用者。（可以使用setjmp/longjmp）


